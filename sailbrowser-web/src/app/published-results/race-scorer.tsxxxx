import { Injectable } from '@angular/core';

import { Race } from 'app/race-calender/@store/race';
import { SeriesScoringScheme } from 'app/race-calender/@store/series-scoring-data';
import { HandicapScheme } from 'app/results-input/@store/handicap-scheme';
import { RaceCompetitor, RESULTS_UNSET_VALUE } from 'app/results-input/@store/race-competitor';
import { ResultCode } from 'app/results-input/@store/result-code';
import { differenceInSeconds } from 'date-fns';


@Injectable({
  providedIn: 'root',
})
export class RaceScorer {
  /**
   * Uses competitor start, finish. lap and status to calculate results for a single race. 
   * All data in the ResultsData object is populated (elapsed/corrected times points and positions).
   * 
   * The exception is some results codes where the points are based on the number of competitors in the series.
   * RESULTS_UNSET_VALUE.  This number is larger than the number of competitors
   * event expected so will be sorted to the bottom of any lists. 
   * 
   * It is assumes all competitors in the race are supplied. 
   * The maximum number of laps and number of starters is calculated based on all competitors. 
   */
  scoreRace(
    competitors: RaceCompetitor[],
    scheme: HandicapScheme,
    race: Race,
    seriesType: SeriesScoringScheme
  ): RaceCompetitor[] {

    // 1. Calculate the maximum number of laps.
    const maxLaps = competitors.reduce((count, comp) => {
        return this.isStartAreaComp(comp.resultCode) ? count + 1 : count;
      }, 0);


    // 2. Calculate elapsed and corrected times, supporting average laps. 
    // The corrected times are for the maximum numbr of laps that better reflects 
    const results = competitors.map((comp) => {

    const times = this.getCorrectedTime(comp, scheme, race.isAverageLap, comp.startTime!);

      // Create a shallow copy with new result data
      const updatedComp = new RaceCompetitor({ ...comp });
      updatedComp.result = {
        elapsedTime: times.elapsed,
        correctedTime: times.corrected,
        position: RESULTS_UNSET_VALUE,
        points: RESULTS_UNSET_VALUE,
        isDiscarded: false,
        isDiscardable: true,
      };

      return updatedComp;
    });

    // 2. Sort by corrected time (taking into account result code)
    results.sort((a, b) => sortByCorrectedTime(a, b));

    // 3. Assign points for finishers
    this.assignPointsForFinishers(results);

    // 4. Assign points for non-finishers
    this.assignPointsForNonFinishers(results, seriesType);

    // 5. Sort by points
    results.sort((a, b) => this.sortByPoints(a, b));

    // 6. Apply scoring penalties
    this.applyScoringPenalties(results, seriesType);

    // Re-sort if penalties changed order
    results.sort((a, b) => this.sortByPoints(a, b));

    return results;
  }

  getCorrectedTime(comp: RaceCompetitor, scheme: HandicapScheme, isAverageLap: boolean, 
    startTime: Date): { corrected: number; elapsed: number; error: string } {

    let corrected = 0.0;
    let elapsed = 0.0;

    const finishTime = comp.finishTime;
    const compStartTime = comp.startTime || startTime;

    if (finishTime && compStartTime) {
      
      const diff = differenceInSeconds(finishTime.getTime(), compStartTime.getTime());

      if (diff < 0) {
        return { corrected: 0, elapsed: 0, error: 'Start time before finish time' };
      }

      const numLaps = comp.numLaps;
      if (isAverageLap && numLaps === 0) {
        return { corrected: 0, elapsed: 0, error: 'Number of laps 0 for average lap race' };
      }

      elapsed = isAverageLap ? (diff / numLaps) : diff;

      switch (scheme) {
        case 'PY':
          corrected = (elapsed * 1000.0) / comp.handicap;
          break;
        case 'Level Rating':
          corrected = elapsed;
          break;
      }
    } else {
      return { corrected: 0, elapsed: 0, error: '' };
    }

    return {
      corrected: Math.round(corrected),
      elapsed: Math.round(elapsed),
      error: '',
    };
  }

  startersInRace(results: RaceCompetitor[]): number {
    return results.reduce((count, comp) => {
      return this.isStartAreaComp(comp.resultCode) ? count + 1 : count;
    }, 0);
  }

  finishersInRace(results: RaceCompetitor[]): number {
    return results.reduce((count, comp) => {
      return this.isFinishedComp(comp.resultCode) ? count + 1 : count;
    }, 0);
  }

  /** Assigns points for finishers in a race
   * Competitors with the same corrected time are 
   * score the averge of points for the time.
   * A map of finish times created to implement this. 
   */
  assignPointsForFinishers(results: RaceCompetitor[]) {
    const finishers = results.filter((res) => this.isFinishedComp(res.resultCode));
    const resultsByTime = new Map<number, RaceCompetitor[]>();

    // Create map of competitors wuth a key of finish time
    finishers.forEach((res) => {
      const time = res.result?.correctedTime || 0;
      if (!resultsByTime.has(time)) resultsByTime.set(time, []);
      resultsByTime.get(time)!.push(res);
    });

    // Itterate over ordered list of finish times calculating points
    const times = Array.from(resultsByTime.keys()).sort((a, b) => a - b);
    let pos = 1.0;

    for (const time of times) {
      const resultsAtTime = resultsByTime.get(time)!;
      // The average points for a group of tied competitors is the average of the positions they would have taken.
      // For example, if 2 boats tie for 2nd, they take up positions 2 and 3, so they both get (2+3)/2 = 2.5 points.
      const avgPoints = pos - 1 + (resultsAtTime.length + 1) / 2.0;

      for (const res of resultsAtTime) {
        if (res.result) {
          res.result.points = avgPoints;
          res.result.position = pos;
        }
      }
      pos += resultsAtTime.length;
    }
  }

  assignPointsForNonFinishers(results: RaceCompetitor[], scheme: SeriesScoringScheme) {
    let starters = -1;

    for (const res of results) {
      if (this.isFinishedComp(res.resultCode)) continue;

      if (this.isStartAreaComp(res.resultCode)) {
        if (starters === -1) starters = this.startersInRace(results);
        if (res.result) {
          res.result.points = starters + 1.0;
          res.result.position = starters + 1;
        }
      } else {
        const totalEntries = results.length;
        if (res.result) {
          res.result.points = totalEntries + 1.0;
          res.result.position = totalEntries + 1;
        }
      }
    }
  }

  applyScoringPenalties(results: RaceCompetitor[], scheme: SeriesScoringScheme) {
    for (const res of results) {
      if (res.resultCode === 'SCP' && res.result) {
        res.result.points = Math.min(res.result.points * 1.2, 99999);
      }
    }
  }

  sortByPoints(a: RaceCompetitor, b: RaceCompetitor): number {
    return (a.result?.points || 9999) - (b.result?.points || 9999);
  }

  private isFinishedComp(code: ResultCode): boolean {
    return [
      'OK',
      'SCP',
      'ZFP',
      'XPA',
      'RDG',
      'RDGA',
      'RDGB',
      'RDGC',
      'DPI',
    ].includes(code);
  }

  private isStartAreaComp(code: ResultCode): boolean {
    return [
      'OK',
      'OOD',
      'DNF',
      'RET',
      'DNS',
      'OCS',
      'ZFP',
      'UFD',
      'BFD',
      'DGM',
      'DSQ',
      'XPA',
      'SCP',
      'RDG',
      'RDGA',
      'RDGB',
      'RDGC',
      'DPI',
    ].includes(code);
  }
}

function isOk(comp: RaceCompetitor): boolean {
  return comp.resultCode === 'OK';
}

export function sortByCorrectedTime(a: RaceCompetitor, b: RaceCompetitor): number {
  const aOk = isOk(a);
  const bOk = isOk(b);

  if (aOk && bOk) {
    return (a.result?.correctedTime || 0) - (b.result?.correctedTime || 0);
  } else if (aOk && !bOk) {
    return -1;
  } else if (!aOk && bOk) {
    return 1;
  } else {
    return 0;
  }
}
